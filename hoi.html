<meta charset="utf-8"/>

<style>
code {white-space:pre;background: #eee;}
code.block {display:block;overflow-x:scroll;margin:1em;}
input.fuint {width:4em;text-align:right;}
input[type="number"]::-webkit-outer-spin-button,
input[type="number"]::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
}
input[type="number"] {
    -moz-appearance: textfield;
}
</style>

<h1>Higher Order Interpolation of OpenType variable fonts</h1>


<h2>Preliminary</h2>


<p>
Quadratic bezier curves are used in the following examples, but any degree bezier should work.
However, high degree curves are difficult to tweak and can run into issues with numerical stability in implementations.
</p>

<p>A quadratic bezier curve with control points <code>P0</code>, <code>P1</code>, <code>P2</code> can be described as
<code class="block">
C(t) = (P0 - 2P1 + P2)t<sup>2</sup> + 2(P1 - P0)t + P0
</code>
</p>

<p>A contour of beziers is a vector of bezier curves with <code>C[n].PN == C[n+1].P0</code>.</p>

<p>
Non-linear interpolation takes advantage of the fact that "The overall scalar is the product of all per-axis scalars."
When a range is defined on more than one axis the per-axis scalars (abbreviated <code>AS</code>, have values on the range <code>[0, 1]</code>) are multiplied together to create the overall scalar which will be multiplied by the deltas.
If a range is defined along <code>axis0, axis1, ..., axisN</code> and all the axis values vary so as to approach the peak at the same rate so that <code>AS1 == AS2 == ... == ASN</code>, then the deltas will be multiplied by <code>AS0*AS1*...*ASN == AS0^N</code>.
However, there are ways to break this. An API could allow setting each axis by index or id. Internally the named instances set values by axis index, so can themselves set the values to anything.
</p>
<p>
Making the axis values all approach the peak at the same rate is easiest to accomplish if all the axes of the region have the same near, far, and peak values.
One possible way to vary the axes together is to give them all the same axis tag, which works because internally the axes are stored as a list of axes and each axis has a tag.
Specifying a variation value by axis tag applies the variation value to all axes with that axis tag in all current major implementations.
While this is not currently required by the specification, this is the only addition to the specification used here<a href="#footnote1">[1]</a>.
Since quadratic beziers are used in the examples, the examples will be using two axes locked together to create the t<sup>2</sup> and t terms required.
</p>


<h2>First attempt</h2>


<p>Since ranges must peak at a single point, constants other than zero are difficult. So re-write <code>P0</code> as <code>P0t + P0(1-t)</code>.
<code class="block">
C(t) = (P0 - 2P1 + P2)t<sup>2</sup> + (2P1 - P0)t + P0(1-t)
</code>
</p>
<p>
To translate this into regions, create three regions where 'begin' is where the curve begins (closest to axis origin) and 'end' is where the curve ends (furthest from axis origin)
<code class="block">
C.region[0] = { axes = [axis1]       , near = begin, far = end, peak = begin, delta = (           P0) }
C.region[1] = { axes = [axis1]       , near = begin, far = end, peak = end  , delta = (     2P1 - P0) }
C.region[2] = { axes = [axis1, axis2], near = begin, far = end, peak = end  , delta = (P2 - 2P1 + P0) }
</code>
</p>
<p>
The number of axes required is <code>deg(C)</code>. The number of regions required is <code>deg(C)+1</code> for each curve.
At most points on a contour <code>deg(C)+1</code> regions are active, with <code>2(deg(C)+1)</code> regions active at any point of curve overlap (including where curves abut, which is bad).
</p>

<h3>Example</h3>
<p>
A not great but easy to understand approximation of a half circle in a square using two quads is to put the on-curve points in the middle of the edges and the off-curve points in the corners.
This example starts with the left point of the half circle approximation at the origin and has it travel clockwise (font space being y-up) in the negative axis direction.

<code class="block">
C[0].P = [(   0,    0), (   0,  512), ( 512,  512)]
C[1].P = [( 512,  512), (1024,  512), (1024,    0)]
</code>
</p>
<p>
Plugging in the numbers for the example
<code class="block">
C[0].region[0].delta  x =    0  y =    0
C[0].region[1].delta  x =    0  y = 1024
C[0].region[2].delta  x =  512  y = -512

C[1].region[0].delta  x =  512  y =  512
C[1].region[1].delta  x = 1536  y =  512
C[1].region[2].delta  x = -512  y = -512
</code>
</p>
<p>
Applying the curves evenly, translating this into ttx notation, and naming the first axis <code>wght</code> and the second <code>WGHT</code> produces the following example.
The ttx format uses the gx term 'tuple' for what is here and in the OpenType specification referred to as a region.
Currently ttx keys axes by tag and not by index, making it less capable than the underlying format, so give the axes different tags.
After compiling with ttx, open with a hex editor and replace <code>WGHT</code> with <code>wght</code>.
<code class="block">
  &lt;fvar&gt;
    &lt;Axis&gt;
      &lt;AxisTag&gt;wght&lt;/AxisTag&gt;
      &lt;Flags&gt;0x1&lt;/Flags&gt;
      &lt;MinValue&gt;400&lt;/MinValue&gt;
      &lt;DefaultValue&gt;500&lt;/DefaultValue&gt;
      &lt;MaxValue&gt;900&lt;/MaxValue&gt;
      &lt;AxisNameID&gt;256&lt;/AxisNameID&gt;
    &lt;/Axis&gt;

    &lt;Axis&gt;
      &lt;AxisTag&gt;WGHT&lt;/AxisTag&gt;
      &lt;Flags&gt;0x1&lt;/Flags&gt;
      &lt;MinValue&gt;400&lt;/MinValue&gt;
      &lt;DefaultValue&gt;500&lt;/DefaultValue&gt;
      &lt;MaxValue&gt;900&lt;/MaxValue&gt;
      &lt;AxisNameID&gt;256&lt;/AxisNameID&gt;
    &lt;/Axis&gt;
  &lt;/fvar&gt;
  &lt;gvar&gt;
    &lt;glyphVariations glyph="foo"&gt;
      &lt;!-- curves heading in the negative axis direction from the origin (default point) --&gt;
      &lt;tuple&gt;
        &lt;coord axis="wght" value="-0.5" min="-0.5" max="0"/&gt;
        &lt;delta pt="0" x="0" y="1024"/&gt;
      &lt;/tuple&gt;
      &lt;tuple&gt;
        &lt;coord axis="wght" value="-0.5" min="-0.5" max="0"/&gt;
        &lt;coord axis="WGHT" value="-0.5" min="-0.5" max="0"/&gt;
        &lt;delta pt="0" x="512" y="-512"/&gt;
      &lt;/tuple&gt;

     &lt;tuple&gt;
        &lt;coord axis="wght" value="-0.5" min="-1.0" max="-0.5"/&gt;
        &lt;delta pt="0" x="512" y="512"/&gt;
      &lt;/tuple&gt;
      &lt;tuple&gt;
        &lt;coord axis="wght" value="-1.0" min="-1.0" max="-0.5"/&gt;
        &lt;delta pt="0" x="1536" y="512"/&gt;
      &lt;/tuple&gt;
      &lt;tuple&gt;
        &lt;coord axis="wght" value="-1.0" min="-1.0" max="-0.5"/&gt;
        &lt;coord axis="WGHT" value="-1.0" min="-1.0" max="-0.5"/&gt;
        &lt;delta pt="0" x="-512" y="-512"/&gt;
      &lt;/tuple&gt;
    &lt;/glyphVariations&gt;
  &lt;/gvar&gt;
</code>
</p>

<h3>Considerations</h3>
<p>
Unfortunately, attempting to construct a contour with consecutive curves <code>C[n]</code> and <code>C[n+1]</code> with the common point <code>Pc == C[n].PN == C[n+1].P0</code> the offset <code>Pc</code> will be double applied where the two contours overlap, resulting in a discontinuity.
Offsetting the constant term or all of <code>C[n+1]</code> by an ULP (1 / 2<sup>14</sup>) may somewhat mitigate, but can still give rise to a discontinuity as the application may allow setting the variation more finely than the ULP available.
</p>


<h2>Second attempt</h2>


<p>The general idea is to avoid discontinuity by assuming a single contour <code>C[0..N]</code> instead of arbitrary curves (G0 continuity) to avoid constants.</p>
<p>
A curve <code>C</code> is applied from near position to peak position as <code>C(t)</code> and fades out from peak position to the far position as <code>C(1-t)</code>.
In order to preserve the offset <code>C(1)</code> over the period <code>C(1-t)</code> is applied one must add in addition <code>C' = C(1) - C(1-t)</code>. (<code>C'</code> here may be pronounced "C compliment".)
This can be interpreted as taking the initial curve </code>C</code>, reversing it, negating that, then translating that by <code>C(1)</code> to re-align.
</p>
<p>
For brevity in the following block, all <code>Pn</code> are <code>C.Pn</code> (the points in the order of the original curve <code>C</code>).
<code class="block">
 C  (t) = ( P0 - 2P1 + P2)t<sup>2</sup> + 2( P1 - P0)t + P0
 Cr (t) = ( P2 - 2P1 + P0)t<sup>2</sup> + 2( P1 - P2)t + P2          //        C(1-t), or C in reverse, or "delta applied as C moves from peak to the far position"
-Cr (t) = (-P2 + 2P1 - P0)t<sup>2</sup> + 2(-P1 + P2)t - P2          //      - C(1-t), or arithmetic inverse of Cr
 C' (t) = (-P2 + 2P1 - P0)t<sup>2</sup> + 2(-P1 + P2)t               // C(1) - C(1-t), or add C(1) = (C.P2) to -Cr

 C' (t) = (-P2 + 2P1 - P0)t<sup>2</sup> + 2(-P1 + P2)t
 C'r(t) = (-P0 + 2P1 - P2)t<sup>2</sup> + 2(-P1 + P0)t + ( P2 - P0)  //         C'(1-t)
-C'r(t) = ( P0 - 2P1 + P2)t<sup>2</sup> + 2( P1 - P0)t + (-P2 + P0)  //       - C'(1-t)
 C''(t) = ( P0 - 2P1 + P2)t<sup>2</sup> + 2( P1 - P0)t               // C'(1) - C'(1-t)

 Co (t) = ( P0 - 2P1 + P2)t<sup>2</sup> + 2( P1 - P0)t               // The curve C(t) translated to the origin, or C(t) - C.P0
 Cor(t) = ( P2 - 2P1 + P0)t<sup>2</sup> + 2( P1 - P2)t + ( P2 - P0)  //          Cor(1-t)
-Cor(t) = (-P2 + 2P1 - P0)t<sup>2</sup> + 2(-P1 + P2)t + (-P2 + P0)  //        - Cor(1-t)
 Co'(t) = (-P2 + 2P1 - P0)t<sup>2</sup> + 2(-P1 + P2)t               // Cor(1) - Cor(1-t)
</code>
<ul>
<li><code>C </code> fades as <code>Cr </code> which is complimented by <code>C'</code>.</li>
<li><code>C'</code> fades as <code>C'r</code> which is complimented by <code>C'' == Co</code>.</li>
<li><code>Co</code> fades as <code>Cor</code> which is complimented by <code>Co' == C'</code>.</li>
</ul>
Importantly, neither of <code>Co</code> or <code>C'</code> has a constant term.
</p>

<p>
Without loss of generality, assume <code>C[0].P0 = (0,0)</code> so that <code>C[0] == Co[0]</code>.
If a discontinuous offset is desired, a <code>Pt + P(1-t)</code> constant delta region (or any shaped region) can be added across the contour (or wherever for that matter).
To avoid double applications or holes two non-zero offsets cannot be next to each other.
Often hard discontinuity can be avoided by allowing contours extremely fast applying curves.
Note that the math can be made to work out for the case with <code>C[0] != Co[0]</code>, but it's messy and one is left with many out of phase sawtooth regions eating into the region limit to provide the constant offset.
</p>
<p>
<code>C[0]</code> is applied from where it starts to <code>C[0].peak</code> as <code>Co[0](t)</code>. It then phases out to the <code>C[1].peak</code> as <code>Co[0](1-t) == Cr[0](t)</code>.
Subsequent curves in the contour may be followed with regions described by
<ul>
<li><code>C[n].near</code> at <code>C[n-1].peak</code></li>
<li><code>C[n].far</code> at <code>C[n+1].peak</code></li>
<li><code>C[n].peak</code> where ever the curve should be fully applied (the logical end of the curve)</li>
<li>adding <code>C[n-1](1) - C[n-1](1-t) == C'[n-1]</code> to preserve the offset <code>C[n-1].PN == C[n].P0 == C[n-1](1) == C[n](0)</code> over the range the previous region is providing <code>C[n-1](1-t) == Cr[n-1](t)</code>.</li>
<li>adding <code>Co[n]</code></li>
</ul>
<code>C[N]</code> works the same way except that <code>C[N].far == C[N].peak</code>.
</p>
<p>
The first line of the following factorings is the <code>C[n-1](1-t) == Cr[n-1](t)</code> of the previous curve being 'unapplied', <code>Cu[n]</code>.
The second line of the following factorings is the <code>C[n-1](1) - C[n-1](1-t) + Co[n]</code> term for the current curve to be 'applied', <code>Ca[n]</code>.
<code class="block">
C[0]   ==
          Co [0]

C[1]   == Cor[0] +
          C' [0] + Co [1]

C[2]   == C'r[0] + Cor[1] +
          Co [0] + C' [1] + Co [2]

C[3]   == Cor[0] + C'r[1] + Cor[2] +
          C' [0] + Co [1] + C' [2] + Co [3]

C[n+2] == C'r[n] + Cor[n+1] +
          C  [n] + C' [n+1] + Co[n+2]
</code>

The <code>Ca</code> curves describe the deltas to apply <code>C</code>.
<code class="block">
Ca[0] = Co[0]
Ca[1] = C'[0]   + Co[1]
Ca[2] = Co[0]   + C'[1]   + Co[2]
Ca[3] = C'[0]   + Co[1]   + C'[2] + Co[3]
Ca[n] = Ca[n-2] + C'[n-1] + Co[n]
</code>
</p>

<p>
The number of axes required is <code>max{deg(C[0]), deg(C[1]), ..., deg(C[N])}</code>.
Since <code>Ca</code> has no constant term, there is no need to use a region to support a constant term.
The number of regions for <code>C[n]</code> will be <code>max{deg(C[n]), deg(C[n-1], ..., deg(C[0])}</code> since <code>Ca[n]</code> depends on all previous curves.
Consider the maximal case where all curves have the same degree <code>D = deg(C[0])</code>.
At the point <code>C[N](1)</code> or while <code>C[0]</code> is being applied <code>D</code> regions are active.
At most other points <code>2D</code> regions are active.
At middle peak points, depending on how the implementation treats edges, either <code>D</code> or <code>3D</code> regions will be active (though <code>2D</code> of those will contribute zero delta at that point).
</p>


<h3>Example</h3>
<p>
A not great but easy to understand approximation of a circle in a square using four quads is to put the on-curve points in the middle of the edges and the off-curve points in the corners.
This example starts with the left point of the circle approximation at the origin and has it travel counter-clockwise (font space being y-up) in the positive axis direction.

<code class="block">
C [0].P = [(   0,    0), (   0, -512), ( 512, -512)]
C [1].P = [( 512, -512), (1024, -512), (1024,    0)]
C [2].P = [(1024,    0), (1024,  512), ( 512,  512)]
C [3].P = [( 512,  512), (   0,  512), (   0,    0)]
</code>

<code class="block">
Co[0].P = [(0, 0), (   0, -512), ( 512, -512)]
Co[1].P = [(0, 0), ( 512,    0), ( 512,  512)]
Co[2].P = [(0, 0), (   0,  512), (-512,  512)]
Co[3].P = [(0, 0), (-512,    0), (-512, -512)]
</code>
</p>

<p>
For ease of calculation note that since <code>Co.P0 == 0</code>
<code class="block">
Co (t) = (Co.P0 - 2Co.P1 + Co.P2)t<sup>2</sup> + 2(Co.P1 - Co.P0)t + Co.P0
       = (Co.P2 - 2Co.P1)t<sup>2</sup> + 2(Co.P1)t

Co'(t) = (-Co.P2 + 2Co.P1 - Co.P0)t<sup>2</sup> + 2(-Co.P1 + Co.P2)t
       = (-Co.P2 + 2Co.P1)t<sup>2</sup> + 2(Co.P2 - Co.P1)t
</code>

Note that this statement of <code>Co' != C'</code> since it assumes <code>Co.P0 == 0</code> and the original <code>C'</code> does not assume <code>C.P0 == 0</code>.
However since this was already assumed when factoring <code>C</code> into <code>Cu + Ca</code> we can use this <code>Co'(t)</code> in place of <code>C'</code> for calculating <code>Ca</code>.
</p>
<p>
Plugging in the numbers for the example
<code class="block">
Co[0](t) x =   512t<sup>2</sup> +     0t  y =  512t<sup>2</sup> + -1024t
C'[0](t) x =  -512t<sup>2</sup> +  1024t  y = -512t<sup>2</sup> +     0t

Co[1](t) x =  -512t<sup>2</sup> +  1024t  y =  512t<sup>2</sup> +     0t
C'[1](t) x =   512t<sup>2</sup> +     0t  y = -512t<sup>2</sup> +  1024t

Co[2](t) x =  -512t<sup>2</sup> +     0t  y = -512t<sup>2</sup> +  1024t
C'[2](t) x =   512t<sup>2</sup> + -1024t  y =  512t<sup>2</sup> +     0t

Co[3](t) x =   512t<sup>2</sup> + -1024t  y = -512t<sup>2</sup> +     0t
</code>
<code class="block">
Ca[0](t) x =   512t<sup>2</sup> +     0t  y =  512t<sup>2</sup> + -1024t
Ca[1](t) x = -1024t<sup>2</sup> +  2048t  y =    0t<sup>2</sup> +     0t
Ca[2](t) x =   512t<sup>2</sup> +     0t  y = -512t<sup>2</sup> +  1024t
Ca[3](t) x =     0t<sup>2</sup> +     0t  y =    0t<sup>2</sup> +     0t
</code>
</p>
<p>
Applying the curves evenly, translating this into ttx notation, and naming the first axis <code>wght</code> and the second <code>WGHT</code> produces the following example.
The ttx format uses the gx term 'tuple' for what is here and in the OpenType specification referred to as a region.
Currently ttx keys axes by tag and not by index, making it less capable than the underlying format, so give the axes different tags.
After compiling with ttx, open with a hex editor and replace <code>WGHT</code> with <code>wght</code>.
<code class="block">
  &lt;fvar&gt;
    &lt;Axis&gt;
      &lt;AxisTag&gt;wght&lt;/AxisTag&gt;
      &lt;Flags&gt;0x1&lt;/Flags&gt;
      &lt;MinValue&gt;400&lt;/MinValue&gt;
      &lt;DefaultValue&gt;500&lt;/DefaultValue&gt;
      &lt;MaxValue&gt;900&lt;/MaxValue&gt;
      &lt;AxisNameID&gt;256&lt;/AxisNameID&gt;
    &lt;/Axis&gt;

    &lt;Axis&gt;
      &lt;AxisTag&gt;WGHT&lt;/AxisTag&gt;
      &lt;Flags&gt;0x1&lt;/Flags&gt;
      &lt;MinValue&gt;400&lt;/MinValue&gt;
      &lt;DefaultValue&gt;500&lt;/DefaultValue&gt;
      &lt;MaxValue&gt;900&lt;/MaxValue&gt;
      &lt;AxisNameID&gt;256&lt;/AxisNameID&gt;
    &lt;/Axis&gt;
  &lt;/fvar&gt;
  &lt;gvar&gt;
    &lt;glyphVariations glyph="foo"&gt;
      &lt;tuple&gt;
        &lt;coord axis="wght" value="0.25" min="0" max="0.5"/&gt;
        &lt;coord axis="WGHT" value="0.25" min="0" max="0.5"/&gt;
        &lt;delta pt="0" x="512" y="512"/&gt;
      &lt;/tuple&gt;
      &lt;tuple&gt;
        &lt;coord axis="wght" value="0.25" min="0" max="0.5"/&gt;
        &lt;delta pt="0" x="0" y="-1024"/&gt;
      &lt;/tuple&gt;

      &lt;tuple&gt;
        &lt;coord axis="wght" value="0.5" min="0.25" max="0.75"/&gt;
        &lt;coord axis="WGHT" value="0.5" min="0.25" max="0.75"/&gt;
        &lt;delta pt="0" x="-1024" y="0"/&gt;
      &lt;/tuple&gt;
      &lt;tuple&gt;
        &lt;coord axis="wght" value="0.5" min="0.25" max="0.75"/&gt;
        &lt;delta pt="0" x="2048" y="0"/&gt;
      &lt;/tuple&gt;

      &lt;tuple&gt;
        &lt;coord axis="wght" value="0.75" min="0.5" max="1.0"/&gt;
        &lt;coord axis="WGHT" value="0.75" min="0.5" max="1.0"/&gt;
        &lt;delta pt="0" x="512" y="-512"/&gt;
      &lt;/tuple&gt;
      &lt;tuple&gt;
        &lt;coord axis="wght" value="0.75" min="0.5" max="1.0"/&gt;
        &lt;delta pt="0" x="0" y="1024"/&gt;
      &lt;/tuple&gt;

      &lt;tuple&gt;
        &lt;coord axis="wght" value="1.0" min="0.75" max="1.0"/&gt;
        &lt;delta pt="0" x="0" y="0"/&gt;
      &lt;/tuple&gt;
      &lt;tuple&gt;
        &lt;coord axis="wght" value="1.0" min="0.75" max="1.0"/&gt;
        &lt;coord axis="WGHT" value="1.0" min="0.75" max="1.0"/&gt;
        &lt;delta pt="0" x="0" y="0"/&gt;
      &lt;/tuple&gt;
    &lt;/glyphVariations&gt;
  &lt;/gvar&gt;
</code>
</p>

<h3>Considerations</h3>
<p>
For brevity this example moves a single point along a contour.
If there are multiple points moving along different curves but the curves are applied over the same regions of axis space then those curves can share regions.
From a simplified editing perspective this is probably easiest to understand as having a 'master' at each point along the diagonal of the axes where a bezier begins/ends, allowing non-linear interpolation for each of the deltas.
If just moving many points as rigid body the <code>IUP</code> like compression of the deltas means only needing to mention a single point.
Also, it is possible to construct a component glyph which specifies attachment points of multiple variable glyphs in order to compose curves across multiple glyphs.
</p>
<p>
This example also only considers the <code>[0,1]</code> side of the axis, but uses the terms <code>near</code> and <code>far</code> instead of <code>min</code> and <code>max</code> to suggest how contours on the <code>[0,-1]</code> side are constructed.
Such contours can be constructed by starting at the origin (zero delta) and go the other way.
</p>
<p>Constants outside the curve can be faked by limiting the <code>min</code> and <code>max</code> values of the axis in the <code>fvar</code> table and then allowing (or expecting) the user to attempt values outside that range, which will be clamped.</p>
<p>
This method admits contours with curves of various degree.
While interesting for specifying a contour, generally the number of regions for <code>C[n]</code> will be <code>max{deg(C[n]), deg(C[n-1], ..., deg(C[0])}</code> since <code>Ca[n]</code> depends on all previous curves.
</p>


<h2>Example</h2>


<p>
A font with the example curves from the first and second attempt applied to some glyphs can be had from <a href="VaryAlongQuad.ttf">VaryAlongQuad.ttf</a>.
It is most instructive to view this font in <a href="https://www.axis-praxis.org/samsa/">Samsa</a>.
This example font has the example curves from both the first and second attempt.
The part of this font derived from the first attempt (user axis values less than 500) will have an odd discontinuous jump between curves on the contour which will show up at user axis value 450 (mapped to internal axis value -0.5).
This discontinuous jump (and avoiding too many active regions at once) is the motivation for doing all the math in the second attempt.
The part of this font derived from the second attempt (user axis values greater than 500) will transition between the curves on the contour smoothly.
</p>


<h2>Third attempt</h2>


<p>
The general idea is to apply and un-apply curves as in the second attempt, but drop the requirement of continuity.
A curve <code>C[n]</code> is applied from near position to peak position as <code>Ca[n](t)</code> and fades out from peak position to the far position as <code>Ca[n](1-t)</code>.
In order to preserve the offset <code>Ca[n](1)</code> over the period <code>Ca[n](1-t)</code> is applied one must add in addition <code>Ca'[n] = Ca[n](1) - Ca[n](1-t)</code>. (<code>C'</code> here may be pronounced "C compliment".)
This can be interpreted as taking the curve <code>Ca</code>, reversing it, negating that, then translating that by <code>Ca(1)</code> to re-align.
In order to travel <code>C[n+1]</code> while <code>Ca'[n]</code> is maintaining <code>Ca[n](1)</code> it is necessary to apply in addition <code>Co[n+1] = C[n+1](t) - Ca[n](1)</code>.
This means applying <code>Ca[n+1] = Ca'[n] + Co[n+1] == C[n+1](t) - Ca[n](1-t)</code>.
<code class="block">
Ca[0] =   C[0](  t)
Ca[1] = - C[0](1-t) + C[1](  t)
Ca[2] =   C[0](  t) - C[1](1-t) + C[2](  t)
Ca[3] = - C[0](1-t) + C[1](  t) - C[2](1-t) + C[3]
Ca[n] = Ca[n-2] - C[n-1](1-t) + C[n]
</code>
</p>

<h3>Example</h3>

<p>
Replicating the example from the second attempt

<code class="block">
 C(t)   = ( P0 - 2P1 + P2)t<sup>2</sup> + 2( P1 - P0)t + P0
-C(1-t) = (-P2 + 2P1 - P0)t<sup>2</sup> + 2(-P1 + P2)t - P2
</code>

<code class="block">
C [0].P = [(   0,    0), (   0, -512), ( 512, -512)]
C [1].P = [( 512, -512), (1024, -512), (1024,    0)]
C [2].P = [(1024,    0), (1024,  512), ( 512,  512)]
C [3].P = [( 512,  512), (   0,  512), (   0,    0)]
</code>

<code class="block">
Ca[0](t) x =   512t<sup>2</sup> +     0t  y =  512t<sup>2</sup> + -1024t
Ca[1](t) x = -1024t<sup>2</sup> +  2048t  y =    0t<sup>2</sup> +     0t
Ca[2](t) x =   512t<sup>2</sup> +     0t  y = -512t<sup>2</sup> +  1024t
Ca[3](t) x =     0t<sup>2</sup> +     0t  y =    0t<sup>2</sup> +     0t
</code>

And end up with the same numbers as the second attempt.
</p>

<p>
With the example from the second attempt, but skipping around and reversing one curve

<code class="block">
C [0].P = [(   0,    0), (   0, -512), ( 512, -512)]
C [1].P = [(1024,    0), (1024,  512), ( 512,  512)]
C [2].P = [(   0,    0), (   0,  512), ( 512,  512)]
C [3].P = [( 512, -512), (1024, -512), (1024,    0)]
</code>

The following inputs start out with the above values.
If script is enabled the rest of the example will update automatically when these values are changed.

<code class="block">
C [0].P = [(<input type="number" class="fuint" id="C0P0x" value="0"/>, <input type="number" class="fuint" id="C0P0y" value="0">), (<input type="number" class="fuint" id="C0P1x" value="0"/>, <input type="number" class="fuint" id="C0P1y" value="-512">), (<input type="number" class="fuint" id="C0P2x" value="512"/>, <input type="number" class="fuint" id="C0P2y" value="-512">)]
C [1].P = [(<input type="number" class="fuint" id="C1P0x" value="1024"/>, <input type="number" class="fuint" id="C1P0y" value="0">), (<input type="number" class="fuint" id="C1P1x" value="1024"/>, <input type="number" class="fuint" id="C1P1y" value="512">), (<input type="number" class="fuint" id="C1P2x" value="512"/>, <input type="number" class="fuint" id="C1P2y" value="512">)]
C [2].P = [(<input type="number" class="fuint" id="C2P0x" value="0"/>, <input type="number" class="fuint" id="C2P0y" value="0">), (<input type="number" class="fuint" id="C2P1x" value="0"/>, <input type="number" class="fuint" id="C2P1y" value="512">), (<input type="number" class="fuint" id="C2P2x" value="512"/>, <input type="number" class="fuint" id="C2P2y" value="512">)]
C [3].P = [(<input type="number" class="fuint" id="C3P0x" value="512"/>, <input type="number" class="fuint" id="C3P0y" value="-512">), (<input type="number" class="fuint" id="C3P1x" value="1024"/>, <input type="number" class="fuint" id="C3P1y" value="-512">), (<input type="number" class="fuint" id="C3P2x" value="1024"/>, <input type="number" class="fuint" id="C3P2y" value="0">)]
</code>

<code class="block">
Ca[0](t) x = <span id="Ca0xt2">0</span>t<sup>2</sup> + <span id="Ca0xt1">0</span>t + <span id="Ca0xt0">0</span>  y = <span id="Ca0yt2">0</span>t<sup>2</sup> + <span id="Ca0yt1">0</span>t + <span id="Ca0yt0">0</span>
Ca[1](t) x = <span id="Ca1xt2">0</span>t<sup>2</sup> + <span id="Ca1xt1">0</span>t + <span id="Ca1xt0">0</span>  y = <span id="Ca1yt2">0</span>t<sup>2</sup> + <span id="Ca1yt1">0</span>t + <span id="Ca1yt0">0</span>
Ca[2](t) x = <span id="Ca2xt2">0</span>t<sup>2</sup> + <span id="Ca2xt1">0</span>t + <span id="Ca2xt0">0</span>  y = <span id="Ca2yt2">0</span>t<sup>2</sup> + <span id="Ca2yt1">0</span>t + <span id="Ca2yt0">0</span>
Ca[3](t) x = <span id="Ca3xt2">0</span>t<sup>2</sup> + <span id="Ca3xt1">0</span>t + <span id="Ca3xt0">0</span>  y = <span id="Ca3yt2">0</span>t<sup>2</sup> + <span id="Ca3yt1">0</span>t + <span id="Ca3yt0">0</span>
</code>
</p>

<p>
But now the constants are not all going to cancel, so the constants will need to be factored
<code class="block">
 C(  t) = ( P0 - 2P1 + P2)t<sup>2</sup> + ( 2P1 - P0)t + P0(1-t)
-C(1-t) = (-P2 + 2P1 - P0)t<sup>2</sup> + (-2P1 + P2)t - P2(1-t)
</code>

<code class="block">
Ca[0](t) x = <span id="Ca'0xt2">0</span>t<sup>2</sup> + <span id="Ca'0xt1">0</span>t + <span id="Ca'0x1t">0</span>(1-t)  y = <span id="Ca'0yt2">0</span>t<sup>2</sup> + <span id="Ca'0yt1">0</span>t + <span id="Ca'0y1t">0</span>(1-t)
Ca[1](t) x = <span id="Ca'1xt2">0</span>t<sup>2</sup> + <span id="Ca'1xt1">0</span>t + <span id="Ca'1x1t">0</span>(1-t)  y = <span id="Ca'1yt2">0</span>t<sup>2</sup> + <span id="Ca'1yt1">0</span>t + <span id="Ca'1y1t">0</span>(1-t)
Ca[2](t) x = <span id="Ca'2xt2">0</span>t<sup>2</sup> + <span id="Ca'2xt1">0</span>t + <span id="Ca'2x1t">0</span>(1-t)  y = <span id="Ca'2yt2">0</span>t<sup>2</sup> + <span id="Ca'2yt1">0</span>t + <span id="Ca'2y1t">0</span>(1-t)
Ca[3](t) x = <span id="Ca'3xt2">0</span>t<sup>2</sup> + <span id="Ca'3xt1">0</span>t + <span id="Ca'3x1t">0</span>(1-t)  y = <span id="Ca'3yt2">0</span>t<sup>2</sup> + <span id="Ca'3yt1">0</span>t + <span id="Ca'3y1t">0</span>(1-t)
</code>
</p>

<p>
But converting those <code>1-t</code> terms to regions is a bit difficult.
They must peak at the near side of the region to produce the discontinuity that they are.
However, they will need to then be re-applied as a <code>t</code> term.
But that <code>t</code> term cannot just end when fully applied at the far side of the region or it will create a discontinuity as in the first attempt.
So apply the <code>t</code> part of this by rolling it into the next region.
However, the extra <code>1-t</code> term on the far side of the next region was not taken into account.
So the region after that will need to also add in a <code>t</code> term to counter the <code>1-t</code> term (and so on).
Effectively, each <code>1-t</code> term as it comes up must be added as a <code>t</code> term to all subsequent regions.

So <code>C[0](t)</code> fades as <code>C[0](1-t)</code>. But leave out the re-apply constant term region and instead fold it into the next next curve.
This means not un-applying <code>C[0].P0(1-t)</code> as <code>C[0].P0(t)</code>. (Only un-apply the <code>t<sup>2</sup></code> and <code>t</code> terms.)
Do the same with each subsequent curve, folding over any <code>1-t</code> bits that need to be re-applied as <code>t</code> bits into the next <code>Ca</code>.

<code class="block">
C [0] ==
           C[0](  t)

C [1] ==   C[0](1-t) - C[0].P0(  t)
         - C[0](1-t) + C[0].P0(  t) + C[1](  t)

C [2] == - C[0](  t) + C[0].P0(1-t) + C[1](1-t) - C[1].P0(  t)
           C[0](  t) - C[0].P0(1-t) - C[1](1-t) + C[1].P0(  t) + C[2](  t)

C [3] ==   C[0](1-t) - C[0].P0(  t) - C[1](  t) + C[1].P0(1-t) + C[2](1-t) - C[2].P0(  t)
         - C[0](1-t) + C[0].P0(  t) + C[1](  t) - C[1].P0(1-t) - C[2](1-t) + C[2].P0(  t) + C[3](  t)

C [n] ==   C[n-1](1-t) - C[n-1].P0(t)
         - C[n-1](1-t) + C[n-1].P0(t) + C[n](t)
</code>

<code class="block">
Ca[0] =   C[0](  t)
Ca[1] = - C[0](1-t) + C[0].P0(  t) + C[1](  t)
Ca[2] =   C[0](  t) - C[0].P0(1-t) - C[1](1-t) + C[1].P0(  t) + C[2](  t)
Ca[3] = - C[0](1-t) + C[0].P0(  t) + C[1](  t) - C[1].P0(1-t) - C[2](1-t) + C[2].P0(  t) + C[3](  t)
Ca[n] =                                -Ca[n-1](1-t) + C[n-1].P0(t) + C[n](t)
Ca[n] =  Ca[n-2](  t) - C[n-2].P0(1-t) - C[n-1](1-t) + C[n-1].P0(t) + C[n](t)
</code>
</p>

<p>
<code class="block">
  &lt;fvar&gt;
    &lt;Axis&gt;
      &lt;AxisTag&gt;wght&lt;/AxisTag&gt;
      &lt;Flags&gt;0x1&lt;/Flags&gt;
      &lt;MinValue&gt;400&lt;/MinValue&gt;
      &lt;DefaultValue&gt;500&lt;/DefaultValue&gt;
      &lt;MaxValue&gt;900&lt;/MaxValue&gt;
      &lt;AxisNameID&gt;256&lt;/AxisNameID&gt;
    &lt;/Axis&gt;

    &lt;Axis&gt;
      &lt;AxisTag&gt;WGHT&lt;/AxisTag&gt;
      &lt;Flags&gt;0x1&lt;/Flags&gt;
      &lt;MinValue&gt;400&lt;/MinValue&gt;
      &lt;DefaultValue&gt;500&lt;/DefaultValue&gt;
      &lt;MaxValue&gt;900&lt;/MaxValue&gt;
      &lt;AxisNameID&gt;256&lt;/AxisNameID&gt;
    &lt;/Axis&gt;
  &lt;/fvar&gt;
  &lt;gvar&gt;
    &lt;glyphVariations glyph="foo"&gt;
      &lt;tuple&gt;
        &lt;coord axis="wght" value="0.25" min="0" max="0.5"/&gt;
        &lt;coord axis="WGHT" value="0.25" min="0" max="0.5"/&gt;
        &lt;delta pt="0" x="<span id="ttxCa'0xt2">0</span>" y="<span id="ttxCa'0yt2">0</span>"/&gt;
      &lt;/tuple&gt;
      &lt;tuple&gt;
        &lt;coord axis="wght" value="0.25" min="0" max="0.5"/&gt;
        &lt;delta pt="0" x="<span id="ttxCa'0xt1">0</span>" y="<span id="ttxCa'0yt1">0</span>"/&gt;
      &lt;/tuple&gt;
      &lt;tuple&gt;
        &lt;coord axis="wght" value="0" min="0" max="0.25"/&gt;
        &lt;delta pt="0" x="<span id="ttxCa'0x1t">0</span>" y="<span id="ttxCa'0y1t">0</span>"/&gt;
      &lt;/tuple&gt;

      &lt;tuple&gt;
        &lt;coord axis="wght" value="0.5" min="0.25" max="0.75"/&gt;
        &lt;coord axis="WGHT" value="0.5" min="0.25" max="0.75"/&gt;
        &lt;delta pt="0" x="<span id="ttxCa'1xt2">0</span>" y="<span id="ttxCa'1yt2">0</span>"/&gt;
      &lt;/tuple&gt;
      &lt;tuple&gt;
        &lt;coord axis="wght" value="0.5" min="0.25" max="0.75"/&gt;
        &lt;delta pt="0" x="<span id="ttxCa'1xt1">0</span>" y="<span id="ttxCa'1yt1">0</span>"/&gt;
      &lt;/tuple&gt;
      &lt;tuple&gt;
        &lt;coord axis="wght" value="0.25" min="0.25" max="0.5"/&gt;
        &lt;delta pt="0" x="<span id="ttxCa'1x1t">0</span>" y="<span id="ttxCa'1y1t">0</span>"/&gt;
      &lt;/tuple&gt;

      &lt;tuple&gt;
        &lt;coord axis="wght" value="0.75" min="0.5" max="1.0"/&gt;
        &lt;coord axis="WGHT" value="0.75" min="0.5" max="1.0"/&gt;
        &lt;delta pt="0" x="<span id="ttxCa'2xt2">0</span>" y="<span id="ttxCa'2yt2">0</span>"/&gt;
      &lt;/tuple&gt;
      &lt;tuple&gt;
        &lt;coord axis="wght" value="0.75" min="0.5" max="1.0"/&gt;
        &lt;delta pt="0" x="<span id="ttxCa'2xt1">0</span>" y="<span id="ttxCa'2yt1">0</span>"/&gt;
      &lt;/tuple&gt;
      &lt;tuple&gt;
        &lt;coord axis="wght" value="0.5" min="0.5" max="0.75"/&gt;
        &lt;delta pt="0" x="<span id="ttxCa'2x1t">0</span>" y="<span id="ttxCa'2y1t">0</span>"/&gt;
      &lt;/tuple&gt;

      &lt;tuple&gt;
        &lt;coord axis="wght" value="1.0" min="0.75" max="1.0"/&gt;
        &lt;coord axis="WGHT" value="1.0" min="0.75" max="1.0"/&gt;
        &lt;delta pt="0" x="<span id="ttxCa'3xt2">0</span>" y="<span id="ttxCa'3yt2">0</span>"/&gt;
      &lt;/tuple&gt;
      &lt;tuple&gt;
        &lt;coord axis="wght" value="1.0" min="0.75" max="1.0"/&gt;
        &lt;delta pt="0" x="<span id="ttxCa'3xt1">0</span>" y="<span id="ttxCa'3yt1">0</span>"/&gt;
      &lt;/tuple&gt;
      &lt;tuple&gt;
        &lt;coord axis="wght" value="0.75" min="0.75" max="1.0"/&gt;
        &lt;delta pt="0" x="<span id="ttxCa'3x1t">0</span>" y="<span id="ttxCa'3y1t">0</span>"/&gt;
      &lt;/tuple&gt;
    &lt;/glyphVariations&gt;
  &lt;/gvar&gt;
</code>

A font file with the default example is available as <a href="VaryAlongQuads.ttf">VaryAlongQuads.ttf</a>.
</p>
<script>

function Point(x, y) {
  this.x = x;
  this.y = y;
}

function Curve(points) {
  this.P = points;
}

function Poly(coefficients) {
  this.t = coefficients;
}

let C = [];
let Ca = [];
let Ca2 = [];
let ttxCa2 = [];
for (let Ci = 0; Ci < 4; ++Ci) {
  let P = [];
  for (let Pi = 0; Pi < 3; ++Pi) {
    P[Pi] = new Point(document.getElementById(`C${Ci}P${Pi}x`),
                      document.getElementById(`C${Ci}P${Pi}y`));
    P[Pi].x.addEventListener('input', updateValue);
    P[Pi].y.addEventListener('input', updateValue);
  }
  C[Ci] = new Curve(P);

  let t = [];
  for (let ti = 0; ti < 3; ++ti) {
    t[ti] = new Point(document.getElementById(`Ca${Ci}xt${ti}`),
                      document.getElementById(`Ca${Ci}yt${ti}`));
  }
  Ca[Ci] = new Poly(t);

  let t2 = [];
  let ttxt2 = [];
  t2[0] = new Point(document.getElementById(`Ca'${Ci}x1t`),
                    document.getElementById(`Ca'${Ci}y1t`));
  ttxt2[0] = new Point(document.getElementById(`ttxCa'${Ci}x1t`),
                       document.getElementById(`ttxCa'${Ci}y1t`));
  for (let ti = 1; ti < 3; ++ti) {
    t2[ti] = new Point(document.getElementById(`Ca'${Ci}xt${ti}`),
                       document.getElementById(`Ca'${Ci}yt${ti}`));
    ttxt2[ti] = new Point(document.getElementById(`ttxCa'${Ci}xt${ti}`),
                          document.getElementById(`ttxCa'${Ci}yt${ti}`));
  }
  Ca2[Ci] = new Poly(t2);
  ttxCa2[Ci] = new Poly(ttxt2);
}

// t[0] is a normal constant term
function polyFromCurve(C) {
  //   C(  t) = ( P0 - 2P1 + P2)t<sup>2</sup> + 2( P1 - P0)t + P0
  let t = [];
  t[2] = new Point(Number(C.P[0].x.value) - 2 * Number(C.P[1].x.value) + Number(C.P[2].x.value),
                   Number(C.P[0].y.value) - 2 * Number(C.P[1].y.value) + Number(C.P[2].y.value));
  t[1] = new Point(2 * (Number(C.P[1].x.value) - Number(C.P[0].x.value)),
                   2 * (Number(C.P[1].y.value) - Number(C.P[0].y.value)));
  t[0] = new Point(Number(C.P[0].x.value),
                   Number(C.P[0].y.value));
  return new Poly(t)
}

// t[0] is a (1-t) term
function polyFromCurveFactoredConstant(C) {
  //   C(  t) = ( P0 - 2P1 + P2)t<sup>2</sup> + ( 2P1 - P0)t + P0(1-t)
  let t = [];
  t[2] = new Point(Number(C.P[0].x.value) - 2 * Number(C.P[1].x.value) + Number(C.P[2].x.value),
                   Number(C.P[0].y.value) - 2 * Number(C.P[1].y.value) + Number(C.P[2].y.value));
  t[1] = new Point(2 * Number(C.P[1].x.value) - Number(C.P[0].x.value),
                   2 * Number(C.P[1].y.value) - Number(C.P[0].y.value));
  t[0] = new Point(Number(C.P[0].x.value),
                   Number(C.P[0].y.value));
  return new Poly(t)
}

// t[0] is a normal constant term
function polyFromCurveCompliment(C) {
  //  -C(1-t) = (-P2 + 2P1 - P0)t<sup>2</sup> + 2(-P1 + P2)t - P2
  let t = [];
  t[2] = new Point(-Number(C.P[2].x.value) + 2 * Number(C.P[1].x.value) - Number(C.P[0].x.value),
                   -Number(C.P[2].y.value) + 2 * Number(C.P[1].y.value) - Number(C.P[0].y.value));
  t[1] = new Point(2 * (-Number(C.P[1].x.value) + Number(C.P[2].x.value)),
                   2 * (-Number(C.P[1].y.value) + Number(C.P[2].y.value)));
  t[0] = new Point(-Number(C.P[2].x.value),
                   -Number(C.P[2].y.value));
  return new Poly(t)
}

// t[0] is a (1-t) term
function polyFromCurveComplimentFactoredConstant(C) {
  //  -C(1-t) = (-P2 + 2P1 - P0)t<sup>2</sup> + (-2P1 + P2)t - P2(1-t)
  let t = [];
  t[2] = new Point(-Number(C.P[2].x.value) + 2 * Number(C.P[1].x.value) - Number(C.P[0].x.value),
                   -Number(C.P[2].y.value) + 2 * Number(C.P[1].y.value) - Number(C.P[0].y.value));
  t[1] = new Point(-2 * Number(C.P[1].x.value) + Number(C.P[2].x.value),
                   -2 * Number(C.P[1].y.value) + Number(C.P[2].y.value));
  t[0] = new Point(-Number(C.P[2].x.value),
                   -Number(C.P[2].y.value));
  return new Poly(t)
}

function updateValue(e) {

  // Ca[0] =   C[0](  t)
  let C0 = polyFromCurve(C[0]);
  Ca[0].t[2].x.textContent = C0.t[2].x;
  Ca[0].t[2].y.textContent = C0.t[2].y;
  Ca[0].t[1].x.textContent = C0.t[1].x;
  Ca[0].t[1].y.textContent = C0.t[1].y;
  Ca[0].t[0].x.textContent = C0.t[0].x;
  Ca[0].t[0].y.textContent = C0.t[0].y;

  let C02 = polyFromCurveFactoredConstant(C[0]);
  Ca2[0].t[2].x.textContent = C02.t[2].x;
  Ca2[0].t[2].y.textContent = C02.t[2].y;
  Ca2[0].t[1].x.textContent = C02.t[1].x;
  Ca2[0].t[1].y.textContent = C02.t[1].y;
  Ca2[0].t[0].x.textContent = C02.t[0].x;
  Ca2[0].t[0].y.textContent = C02.t[0].y;

  ttxCa2[0].t[2].x.textContent = C02.t[2].x;
  ttxCa2[0].t[2].y.textContent = C02.t[2].y;
  ttxCa2[0].t[1].x.textContent = C02.t[1].x;
  ttxCa2[0].t[1].y.textContent = C02.t[1].y;
  ttxCa2[0].t[0].x.textContent = C02.t[0].x;
  ttxCa2[0].t[0].y.textContent = C02.t[0].y;


  // Ca[1] = - C[0](1-t) + C[1](  t)
  let C0u = polyFromCurveCompliment(C[0]);
  let C1 = polyFromCurve(C[1]);
  Ca[1].t[2].x.textContent = C0u.t[2].x + C1.t[2].x;
  Ca[1].t[2].y.textContent = C0u.t[2].y + C1.t[2].y;
  Ca[1].t[1].x.textContent = C0u.t[1].x + C1.t[1].x;
  Ca[1].t[1].y.textContent = C0u.t[1].y + C1.t[1].y;
  Ca[1].t[0].x.textContent = C0u.t[0].x + C1.t[0].x;
  Ca[1].t[0].y.textContent = C0u.t[0].y + C1.t[0].y;

  let C0u2 = polyFromCurveComplimentFactoredConstant(C[0]);
  let C12 = polyFromCurveFactoredConstant(C[1]);
  Ca2[1].t[2].x.textContent = C0u2.t[2].x + C12.t[2].x;
  Ca2[1].t[2].y.textContent = C0u2.t[2].y + C12.t[2].y;
  Ca2[1].t[1].x.textContent = C0u2.t[1].x + C12.t[1].x;
  Ca2[1].t[1].y.textContent = C0u2.t[1].y + C12.t[1].y;
  Ca2[1].t[0].x.textContent = C0u2.t[0].x + C12.t[0].x;
  Ca2[1].t[0].y.textContent = C0u2.t[0].y + C12.t[0].y;

  // Ca[1] = - C[0](1-t) + C[0].P0(  t) + C[1](  t)
  ttxCa2[1].t[2].x.textContent = C0u2.t[2].x + C12.t[2].x;
  ttxCa2[1].t[2].y.textContent = C0u2.t[2].y + C12.t[2].y;
  ttxCa2[1].t[1].x.textContent = C0u2.t[1].x + C12.t[1].x + Number(C[0].P[0].x.value);
  ttxCa2[1].t[1].y.textContent = C0u2.t[1].y + C12.t[1].y + Number(C[0].P[0].y.value);
  ttxCa2[1].t[0].x.textContent = C0u2.t[0].x + C12.t[0].x;
  ttxCa2[1].t[0].y.textContent = C0u2.t[0].y + C12.t[0].y;

  for (Ci = 2; Ci < Ca.length; ++Ci) {
    // Ca[n] = Ca[n-2] - C[n-1](1-t) + C[n]
    let Cn1u = polyFromCurveCompliment(C[Ci-1]);
    let Cn = polyFromCurve(C[Ci]);
    Ca[Ci].t[2].x.textContent = Number(Ca[Ci-2].t[2].x.textContent) + Cn1u.t[2].x + Cn.t[2].x;
    Ca[Ci].t[2].y.textContent = Number(Ca[Ci-2].t[2].y.textContent) + Cn1u.t[2].y + Cn.t[2].y;
    Ca[Ci].t[1].x.textContent = Number(Ca[Ci-2].t[1].x.textContent) + Cn1u.t[1].x + Cn.t[1].x;
    Ca[Ci].t[1].y.textContent = Number(Ca[Ci-2].t[1].y.textContent) + Cn1u.t[1].y + Cn.t[1].y;
    Ca[Ci].t[0].x.textContent = Number(Ca[Ci-2].t[0].x.textContent) + Cn1u.t[0].x + Cn.t[0].x;
    Ca[Ci].t[0].y.textContent = Number(Ca[Ci-2].t[0].y.textContent) + Cn1u.t[0].y + Cn.t[0].y;

    let Cn1u2 = polyFromCurveComplimentFactoredConstant(C[Ci-1]);
    let Cn2 = polyFromCurveFactoredConstant(C[Ci]);
    Ca2[Ci].t[2].x.textContent = Number(Ca2[Ci-2].t[2].x.textContent) + Cn1u2.t[2].x + Cn2.t[2].x;
    Ca2[Ci].t[2].y.textContent = Number(Ca2[Ci-2].t[2].y.textContent) + Cn1u2.t[2].y + Cn2.t[2].y;
    Ca2[Ci].t[1].x.textContent = Number(Ca2[Ci-2].t[1].x.textContent) + Cn1u2.t[1].x + Cn2.t[1].x;
    Ca2[Ci].t[1].y.textContent = Number(Ca2[Ci-2].t[1].y.textContent) + Cn1u2.t[1].y + Cn2.t[1].y;
    Ca2[Ci].t[0].x.textContent = Number(Ca2[Ci-2].t[0].x.textContent) + Cn1u2.t[0].x + Cn2.t[0].x;
    Ca2[Ci].t[0].y.textContent = Number(Ca2[Ci-2].t[0].y.textContent) + Cn1u2.t[0].y + Cn2.t[0].y;

    // Ca[n] = Ca[n-2](t) - Ca[n-2].P0(1-t) - C[n-1](1-t) + Ca[n-1].P0(t) + C[n](t)
    ttxCa2[Ci].t[2].x.textContent = Number(ttxCa2[Ci-2].t[2].x.textContent) + Cn1u2.t[2].x + Cn2.t[2].x;
    ttxCa2[Ci].t[2].y.textContent = Number(ttxCa2[Ci-2].t[2].y.textContent) + Cn1u2.t[2].y + Cn2.t[2].y;
    ttxCa2[Ci].t[1].x.textContent = Number(ttxCa2[Ci-2].t[1].x.textContent) + Cn1u2.t[1].x + Cn2.t[1].x + Number(ttxCa2[Ci-1].t[0].x.textContent);
    ttxCa2[Ci].t[1].y.textContent = Number(ttxCa2[Ci-2].t[1].y.textContent) + Cn1u2.t[1].y + Cn2.t[1].y + Number(ttxCa2[Ci-1].t[0].y.textContent);
    //ttxCa2[Ci].t[0].x.textContent = Number(ttxCa2[Ci-2].t[0].x.textContent) + Cn1u2.t[0].x + Cn2.t[0].x - Number(ttxCa2[Ci-2].t[0].x.textContent);
    //ttxCa2[Ci].t[0].y.textContent = Number(ttxCa2[Ci-2].t[0].y.textContent) + Cn1u2.t[0].y + Cn2.t[0].y - Number(ttxCa2[Ci-2].t[0].y.textContent);
    ttxCa2[Ci].t[0].x.textContent = Cn1u2.t[0].x + Cn2.t[0].x;
    ttxCa2[Ci].t[0].y.textContent = Cn1u2.t[0].y + Cn2.t[0].y;
  }
}
updateValue();
</script>

<h3>Considerations</h3>

<p>
This does not make the assumption of a continuous contour and allows for contolled discontinuity.
This is a generalization of the second attempt, which essentially does the same thing except demand that <code>C[n-1].P2 == C[n].PN</code> so that the constant terms cancel out.
If these terms do not cancel one will require an extra region per curve on the contour in order to support the constant term (as was done in the first attempt).
</p>


<h2>More attempts</h2>


<p>
Another possible way to support a constant without discontinuity between curves of a contour is to exploit more axes with the same tag, but allow the min and max to differ.
<code>C[0]</code> would be done as in the first attempt example but with the min and max of its axes set to the begin and end of the region the curve occupies.
Then add another set of axes to describe <code>C[1]</code> by <code>C[1] - C[0](1)</code> over the next region with different min and max from the axes for <code>C[0]</code>.
This has the property of showing something which could be interestingly done with axes with the same tag with different min, max, and default.
However, it has the downside of using a lot of axes and having a lot of active regions.
</p>
<p>
Yet another possible way to support the constant would be to to do <code>C[0]</code> with the end of the region at the end of the contour.
This would the be balanced by having another region go from <code>C[0].peak</code> to <code>C[0].far</code> applying <code>C'[0]</code> to maintain the constant.
Then the regions for the other curves can be stacked on top in a similar way.
This uses fewer axes, but many regions, due to the fact that the curves aren't sharing regions.
</p>
<p>Both of these seem interesting areas to think about, but seem strictly less practical.</p>


<h2>Footnotes</h2>


<ol>
<li id="footnote1">
Technically the specification would probably also want all axes with the same tag to have the same min, max, and default as well.
Someone might find some sneaky use for these not being the same, so one proposal is to require all but one axis with a given axis tag to be marked hidden so APIs know which one to use to report the min, max, and default values.
However here they are all given the same values.
</li>
</ol>
